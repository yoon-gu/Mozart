import numpy as np
import numpy.testing as npt
from numpy import linalg as LA

def test_compute_n4s():
	from mozart.poisson.fem.cube import compute_n4s
	n4e = np.array([[0, 1, 4, 3, 6, 7, 10, 9], [1, 2, 5, 4, 7, 8, 11, 10]])
	n4s = compute_n4s(n4e)
	ref_n4s = np.array([[ 0,  1], [ 1,  2], [ 1,  4], [ 2,  5], [ 4,  3], 
		[ 5,  4], [ 3,  0], [ 0,  6], [ 1,  7], [ 2,  8], [ 4, 10], 
		[ 5, 11], [ 3,  9], [ 6,  7], [ 7,  8], [ 7, 10], [ 8, 11], 
		[10,  9], [11, 10], [ 9,  6]], dtype = int)
	npt.assert_almost_equal(n4s, ref_n4s, decimal=8)

def test_compute_s4e():
	from mozart.poisson.fem.cube import compute_s4e
	n4e = np.array([[0, 1, 4, 3, 6, 7, 10, 9], [1, 2, 5, 4, 7, 8, 11, 10]])
	s4e = compute_s4e(n4e)
	ref_s4e = np.array([[ 0,  2,  4,  6,  7,  8, 10, 12, 13, 15, 17, 19],
				[ 1,  3,  5,  2,  8,  9, 11, 10, 14, 16, 18, 15]], dtype = int)
	npt.assert_almost_equal(s4e, ref_s4e, decimal=8)

def test_compute_n4f():
	from mozart.poisson.fem.cube import compute_n4f
	n4e = np.array([[0, 1, 4, 3, 6, 7, 10, 9], [1, 2, 5, 4, 7, 8, 11, 10]])
	n4f = compute_n4f(n4e)
	ref_n4f = np.array([[ 0,  1,  4,  3], [ 1,  2,  5,  4], [ 0,  1,  7,  6], [ 1,  2,  8,  7], 
				[ 1,  4, 10,  7], [ 2,  5, 11,  8], [ 4,  3,  9, 10], [ 5,  4, 10, 11], 
				[ 3,  0,  6,  9], [ 6,  7, 10,  9], [ 7,  8, 11, 10]], dtype = int)
	npt.assert_almost_equal(n4f, ref_n4f, decimal=8)

def test_compute_f4e():
	from mozart.poisson.fem.cube import compute_f4e
	n4e = np.array([[0, 1, 4, 3, 6, 7, 10, 9], [1, 2, 5, 4, 7, 8, 11, 10]])
	f4e = compute_f4e(n4e)
	ref_f4e = np.array([[ 0,  2,  4,  6,  8,  9],
				[ 1,  3,  5,  7,  4, 10]])
	npt.assert_almost_equal(f4e, ref_f4e, decimal=8)

def test_compute_e4f():
	from mozart.poisson.fem.cube import compute_e4f
	n4e = np.array([[0, 1, 4, 3, 6, 7, 10, 9], [1, 2, 5, 4, 7, 8, 11, 10]])
	e4f = compute_e4f(n4e)
	ref_e4f = np.array([[ 0, -1], [ 0, -1], [ 0, -1], [ 0, -1], [ 0,  1], [ 0, -1], 
				[ 1, -1], [ 1, -1], [ 1, -1], [ 1, -1], [ 1, -1]], dtype = int)
	npt.assert_almost_equal(e4f, ref_e4f, decimal=8)

def test_getIndex():
	from mozart.poisson.fem.cube import getIndex
	c4n = np.array([[0., 0., 0.], [1., 0., 0.], [2., 0., 0.], [0., 1., 0.],
				[1., 1., 0.], [2., 1., 0.], [0., 0., 1.], [1., 0., 1.],
				[2., 0., 1.], [0., 1., 1.], [1., 1., 1.], [2., 1., 1.]])
	n4e = np.array([[0, 1, 4, 3, 6, 7, 10, 9], [1, 2, 5, 4, 7, 8, 11, 10]])
	n4fDb = np.array([[0, 1, 7, 6], [1, 2, 8, 7], [2, 5, 11, 8], [5, 4, 10, 11],
				  [4, 3, 9, 10], [3, 0, 6, 9], [6, 7, 10, 9], [7, 8, 11, 10]])
	n4fNb = np.array([[0, 1, 4, 3], [1, 2, 5, 4]])
	c4nNew, ind4e, ind4Db, ind4Nb = getIndex(3, c4n, n4e, n4fDb, n4fNb)
	ref_c4nNew = np.array([[0.0,  0.0,  0.0], [ 1.0,  0.0,  0.0], [ 2.0,  0.0,  0.0], [ 0.0,  1.0,  0.0], 
						   [ 1.0,  1.0,  0.0], [ 2.0,  1.0,  0.0], [ 0.0,  0.0,  1.0], [ 1.0,  0.0,  1.0], 
						   [ 2.0,  0.0,  1.0], [ 0.0,  1.0,  1.0], [ 1.0,  1.0,  1.0], [ 2.0,  1.0,  1.0], 
						   [ 1.0/3,  0.0,  0.0], [ 2.0/3,  0.0,  0.0], [ 4.0/3,  0.0,  0.0], [ 5.0/3,  0.0,  0.0], 
						   [ 1.0,  1.0/3,  0.0], [ 1.0,  2.0/3,  0.0], [ 2.0,  1.0/3,  0.0], [ 2.0,  2.0/3,  0.0], 
						   [ 2.0/3,  1.0,  0.0], [ 1.0/3,  1.0,  0.0], [ 5.0/3,  1.0,  0.0], [ 4.0/3,  1.0,  0.0], 
						   [ 0.0,  2.0/3,  0.0], [ 0.0,  1.0/3,  0.0], [ 0.0,  0.0,  1.0/3], [ 0.0,  0.0,  2.0/3], 
						   [ 1.0,  0.0,  1.0/3], [ 1.0,  0.0,  2.0/3], [ 2.0,  0.0,  1.0/3], [ 2.0,  0.0,  2.0/3], 
						   [ 1.0,  1.0,  1.0/3], [ 1.0,  1.0,  2.0/3], [ 2.0,  1.0,  1.0/3], [ 2.0,  1.0,  2.0/3], 
						   [ 0.0,  1.0,  1.0/3], [ 0.0,  1.0,  2.0/3], [ 1.0/3,  0.0,  1.0], [ 2.0/3,  0.0,  1.0], 
						   [ 4.0/3,  0.0,  1.0], [ 5.0/3,  0.0,  1.0], [ 1.0,  1.0/3,  1.0], [ 1.0,  2.0/3,  1.0], 
						   [ 2.0,  1.0/3,  1.0], [ 2.0,  2.0/3,  1.0], [ 2.0/3,  1.0,  1.0], [ 1.0/3,  1.0,  1.0], 
						   [ 5.0/3,  1.0,  1.0], [ 4.0/3,  1.0,  1.0], [ 0.0,  2.0/3,  1.0], [ 0.0,  1.0/3,  1.0], 
						   [ 1.0/3,  1.0/3,  0.0], [ 2.0/3,  1.0/3,  0.0], [ 1.0/3,  2.0/3,  0.0], [ 2.0/3,  2.0/3,  0.0], 
						   [ 4.0/3,  1.0/3,  0.0], [ 5.0/3,  1.0/3,  0.0], [ 4.0/3,  2.0/3,  0.0], [ 5.0/3,  2.0/3,  0.0], 
						   [ 1.0/3,  0.0,  1.0/3], [ 2.0/3,  0.0,  1.0/3], [ 1.0/3,  0.0,  2.0/3], [ 2.0/3,  0.0,  2.0/3], 
						   [ 4.0/3,  0.0,  1.0/3], [ 5.0/3,  0.0,  1.0/3], [ 4.0/3,  0.0,  2.0/3], [ 5.0/3,  0.0,  2.0/3], 
						   [ 1.0,  1.0/3,  1.0/3], [ 1.0,  2.0/3,  1.0/3], [ 1.0,  1.0/3,  2.0/3], [ 1.0,  2.0/3,  2.0/3], 
						   [ 2.0,  1.0/3,  1.0/3], [ 2.0,  2.0/3,  1.0/3], [ 2.0,  1.0/3,  2.0/3], [ 2.0,  2.0/3,  2.0/3], 
						   [ 2.0/3,  1.0,  1.0/3], [ 1.0/3,  1.0,  1.0/3], [ 2.0/3,  1.0,  2.0/3], [ 1.0/3,  1.0,  2.0/3], 
						   [ 5.0/3,  1.0,  1.0/3], [ 4.0/3,  1.0,  1.0/3], [ 5.0/3,  1.0,  2.0/3], [ 4.0/3,  1.0,  2.0/3], 
						   [ 0.0,  2.0/3,  1.0/3], [ 0.0,  1.0/3,  1.0/3], [ 0.0,  2.0/3,  2.0/3], [ 0.0,  1.0/3,  2.0/3], 
						   [ 1.0/3,  1.0/3,  1.0], [ 2.0/3,  1.0/3,  1.0], [ 1.0/3,  2.0/3,  1.0], [ 2.0/3,  2.0/3,  1.0], 
						   [ 4.0/3,  1.0/3,  1.0], [ 5.0/3,  1.0/3,  1.0], [ 4.0/3,  2.0/3,  1.0], [ 5.0/3,  2.0/3,  1.0], 
						   [ 1.0/3,  1.0/3,  1.0/3], [ 2.0/3,  1.0/3,  1.0/3], [ 1.0/3,  2.0/3,  1.0/3], [ 2.0/3,  2.0/3,  1.0/3], 
						   [ 1.0/3,  1.0/3,  2.0/3], [ 2.0/3,  1.0/3,  2.0/3], [ 1.0/3,  2.0/3,  2.0/3], [ 2.0/3,  2.0/3,  2.0/3], 
						   [ 4.0/3,  1.0/3,  1.0/3], [ 5.0/3,  1.0/3,  1.0/3], [ 4.0/3,  2.0/3,  1.0/3], [ 5.0/3,  2.0/3,  1.0/3], 
						   [ 4.0/3,  1.0/3,  2.0/3], [ 5.0/3,  1.0/3,  2.0/3], [ 4.0/3,  2.0/3,  2.0/3], [ 5.0/3,  2.0/3,  2.0/3]])
	ref_ind4e = np.array([[  0,  12,  13,   1,  25,  52,  53,  16,  24,  54,  55,  17,   3,
							21,  20,   4,  26,  60,  61,  28,  85,  96,  97,  68,  84,  98,
							99,  69,  36,  77,  76,  32,  27,  62,  63,  29,  87, 100, 101,
							70,  86, 102, 103,  71,  37,  79,  78,  33,   6,  38,  39,   7,
							51,  88,  89,  42,  50,  90,  91,  43,   9,  47,  46,  10],
						   [  1,  14,  15,   2,  16,  56,  57,  18,  17,  58,  59,  19,   4,
							 23,  22,   5,  28,  64,  65,  30,  69, 104, 105,  72,  68, 106, 
							107,  73,  32,  80,  81,  34,  29,  66,  67,  31,  71, 108, 109,
							 74,  70, 110, 111,  75,  33,  82,  83,  35,   7,  40,  41,   8,
							 42,  92,  93,  44,  43,  94,  95,  45,  10,  49,  48,  11]])
	ref_ind4Db = np.array([  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 18, 
							19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 
							36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 60, 
							61, 62, 63, 64, 65, 66, 67, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 
							82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95])
	ref_ind4Nb = np.array([[ 0, 12, 13,  1, 25, 52, 53, 16, 24, 54, 55, 17,  3, 21, 20,  4],
						   [ 1, 14, 15,  2, 16, 56, 57, 18, 17, 58, 59, 19,  4, 23, 22,  5]])
	npt.assert_almost_equal(c4nNew, ref_c4nNew, decimal=8)
	npt.assert_almost_equal(ind4e, ref_ind4e, decimal=8)
	npt.assert_almost_equal(ind4Db, ref_ind4Db, decimal=8)
	npt.assert_almost_equal(ind4Nb, ref_ind4Nb, decimal=8)

def test_getPoissonMatrix3D():
	from mozart.poisson.fem.cube import getMatrix
	M_R, M2D_R, Srr_R, Sss_R, Stt_R, Dr_R, Ds_R, Dt_R = getMatrix(1)
	ref_M_R = np.array([[8, 4, 4, 2, 4, 2, 2, 1],
				       [4, 8, 2, 4, 2, 4, 1, 2],
				       [4, 2, 8, 4, 2, 1, 4, 2],
				       [2, 4, 4, 8, 1, 2, 2, 4],
				       [4, 2, 2, 1, 8, 4, 4, 2],
				       [2, 4, 1, 2, 4, 8, 2, 4],
				       [2, 1, 4, 2, 4, 2, 8, 4],
				       [1, 2, 2, 4, 2, 4, 4, 8]]) / 27.
	ref_M2D_R = np.array([[4, 2, 2, 1],  [2, 4, 1, 2],  
						 [2, 1, 4, 2],  [1, 2, 2, 4]]) / 9.
	ref_Srr_R = np.array([[ 4, -4,  2, -2,  2, -2,  1, -1],
						 [-4,  4, -2,  2, -2,  2, -1,  1],
						 [ 2, -2,  4, -4,  1, -1,  2, -2],
						 [-2,  2, -4,  4, -1,  1, -2,  2],
						 [ 2, -2,  1, -1,  4, -4,  2, -2],
						 [-2,  2, -1,  1, -4,  4, -2,  2],
						 [ 1, -1,  2, -2,  2, -2,  4, -4],
						 [-1,  1, -2,  2, -2,  2, -4,  4 ]]) / 18.
	ref_Sss_R = np.array([[ 4,  2, -4, -2,  2,  1, -2, -1],
						 [ 2,  4, -2, -4,  1,  2, -1, -2],
						 [-4, -2,  4,  2, -2, -1,  2,  1],
						 [-2, -4,  2,  4, -1, -2,  1,  2],
						 [ 2,  1, -2, -1,  4,  2, -4, -2],
						 [ 1,  2, -1, -2,  2,  4, -2, -4],
						 [-2, -1,  2,  1, -4, -2,  4,  2],
						 [-1, -2,  1,  2, -2, -4,  2,  4]]) / 18.
	ref_Stt_R = np.array([[ 4,  2,  2,  1, -4, -2, -2, -1],
						 [ 2,  4,  1,  2, -2, -4, -1, -2],
						 [ 2,  1,  4,  2, -2, -1, -4, -2],
						 [ 1,  2,  2,  4, -1, -2, -2, -4],
						 [-4, -2, -2, -1,  4,  2,  2,  1],
						 [-2, -4, -1, -2,  2,  4,  1,  2],
						 [-2, -1, -4, -2,  2,  1,  4,  2],
						 [-1, -2, -2, -4,  1,  2,  2,  4]]) / 18.
	ref_Dr_R = np.array([[-1, 1,  0, 0,  0, 0,  0, 0],
						[-1, 1,  0, 0,  0, 0,  0, 0],
						[ 0, 0, -1, 1,  0, 0,  0, 0],
						[ 0, 0, -1, 1,  0, 0,  0, 0],
						[ 0, 0,  0, 0, -1, 1,  0, 0],
						[ 0, 0,  0, 0, -1, 1,  0, 0],
						[ 0, 0,  0, 0,  0, 0, -1, 1],
						[ 0, 0,  0, 0,  0, 0, -1, 1]]) / 2.
	ref_Ds_R = np.array([[-1,  0, 1, 0,  0,  0, 0, 0],
						[ 0, -1, 0, 1,  0,  0, 0, 0],
						[-1,  0, 1, 0,  0,  0, 0, 0],
						[ 0, -1, 0, 1,  0,  0, 0, 0],
						[ 0,  0, 0, 0, -1,  0, 1, 0],
						[ 0,  0, 0, 0,  0, -1, 0, 1],
						[ 0,  0, 0, 0, -1,  0, 1, 0],
						[ 0,  0, 0, 0,  0, -1, 0, 1]]) / 2.
	ref_Dt_R = np.array([[-1,  0,  0,  0, 1, 0, 0, 0],
						[ 0, -1,  0,  0, 0, 1, 0, 0],
						[ 0,  0, -1,  0, 0, 0, 1, 0],
						[ 0,  0,  0, -1, 0, 0, 0, 1],
						[-1,  0,  0,  0, 1, 0, 0, 0],
						[ 0, -1,  0,  0, 0, 1, 0, 0],
						[ 0,  0, -1,  0, 0, 0, 1, 0],
						[ 0,  0,  0, -1, 0, 0, 0, 1]]) / 2.
	npt.assert_almost_equal(M_R, ref_M_R, decimal=8)
	npt.assert_almost_equal(M2D_R, ref_M2D_R, decimal=8)
	npt.assert_almost_equal(Srr_R, ref_Srr_R, decimal=8)
	npt.assert_almost_equal(Sss_R, ref_Sss_R, decimal=8)
	npt.assert_almost_equal(Stt_R, ref_Stt_R, decimal=8)
	npt.assert_almost_equal(Dr_R, ref_Dr_R, decimal=8)
	npt.assert_almost_equal(Ds_R, ref_Ds_R, decimal=8)
	npt.assert_almost_equal(Dt_R, ref_Dt_R, decimal=8)

def test_solve():
	from mozart.mesh.cube import cube
	from mozart.poisson.fem.cube import solve
	x1, x2, y1, y2, z1, z2, Mx, My, Mz, N = (0, 1, 0, 1, 0, 1, 3, 3, 3, 1)
	c4n, ind4e, n4e, n4Db = cube(x1,x2,y1,y2,z1,z2,Mx,My,Mz,N)
	f = lambda x,y,z: 3.0*np.pi**2*np.sin(np.pi*x)*np.sin(np.pi*y)*np.sin(np.pi*z)
	u_D = lambda x,y,z: 0*x
	x = solve(c4n, ind4e, n4e, n4Db, f, u_D, N)
	ref_x = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					   0.593564453933756, 0.593564453933756, 0, 0, 0.593564453933756,
					   0.593564453933756, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					   0.593564453933756, 0.593564453933756, 0, 0, 0.593564453933756,
					   0.593564453933756, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

	npt.assert_almost_equal(x, ref_x, decimal=8)

def test_computeError():
	from mozart.mesh.cube import cube
	from mozart.poisson.fem.cube import solve
	from mozart.poisson.fem.cube import computeError
	iter = 3
	for degree in range(1,4):
		f = lambda x,y,z: 3.0*np.pi**2*np.sin(np.pi*x)*np.sin(np.pi*y)*np.sin(np.pi*z)
		u_D = lambda x,y,z: 0*x
		exact_u = lambda x,y,z: np.sin(np.pi*x)*np.sin(np.pi*y)*np.sin(np.pi*z)
		exact_ux = lambda x,y,z: np.pi*np.cos(np.pi*x)*np.sin(np.pi*y)*np.sin(np.pi*z)
		exact_uy = lambda x,y,z: np.pi*np.sin(np.pi*x)*np.cos(np.pi*y)*np.sin(np.pi*z)
		exact_uz = lambda x,y,z: np.pi*np.sin(np.pi*x)*np.sin(np.pi*y)*np.cos(np.pi*z)
		sH1error = np.zeros(iter, dtype = np.float64)
		h = np.zeros(iter, dtype = np.float64)
		for j in range(0,iter):
			c4n, ind4e, n4e, n4Db = cube(0,1,0,1,0,1,2**(j+1),2**(j+1),2**(j+1),degree)
			x = solve(c4n, ind4e, n4e, n4Db, f, u_D, degree)
			sH1error[j] = computeError(c4n, n4e, ind4e, exact_u, exact_ux, exact_uy, exact_uz, x, degree, degree+3)
			h[j] = 1 / 2.0**(j+1)
		ratesH1=(np.log(sH1error[1:])-np.log(sH1error[0:-1]))/(np.log(h[1:])-np.log(h[0:-1]))
		npt.assert_array_less(degree-0.2, ratesH1[-1])
		#self.assertTrue(np.abs(rateH1[-1]) > degree-0.2, \
				#"Convergence rate : {0} when trying degree = {1}".format(np.abs(rateH1[-1]), degree))